/**
 * 精选文章：
 * https://zhuanlan.zhihu.com/p/371530318
 * https://zhuanlan.zhihu.com/p/227951185
 * https://wenku.baidu.com/view/e6e9f232cf7931b765ce0508763231126edb77e5.html
 * https://blog.csdn.net/weixin_36020178/article/details/117908638
 */

// console.log(0.1 + 0.2 === 0.3) // false
// console.log(0.1 + 0.2) // 0.30000000000000004

// 问：0.1加0.2等不等于0.3？
// 答：不等于

// 问：为什么不等于？
// 答：IEEE754标准

/**
 * 十进制转换成二进制：
 * 整数部分除以2反向取余
 * 小数部分乘以2正向取整
 */
// 第一步：十进制0.1转换成二进制
// 0.1 * 2 = 0.2    整数：0    小数：0.2
// 0.2 * 2 = 0.4    整数：0    小数：0.4
// 0.4 * 2 = 0.8    整数：0    小数：0.8
// 0.8 * 2 = 1.6    整数：1    小数：0.6
// 0.6 * 2 = 1.2    整数：1    小数：0.2
// 0.2 * 2 = 0.4    整数：0    小数：0.4
// 0.4 * 2 = 0.8    整数：0    小数：0.8
// 0.8 * 2 = 1.6    整数：1    小数：0.6
// 0.6 * 2 = 1.2    整数：1    小数：0.2
// 0.2 * 2 = 0.4    整数：0    小数：0.4
// ...
// 所以0.1 = 0.000110011...(0011)无限循环

// 第二步：将0.1转换过后的二进制通过科学计数法表示
// 0.000110011...(0011)无限循环 = 1.10011001...(1001)无限循环 * 2^-4

// 第三步：将通过科学计数法表示的二进制转换为IEEE745标准表示
// 规格化，简言之就是求符号位、指数偏移值和尾数
// 1. 符号位：0表示正数，1表示负数
//    因此，0.1的符号位 = 0
// 2. 指数偏移值：双精度浮点数固定偏移值（2^(11-1)-1）加上指数实际值（即2^-4中的-4）的11位二进制表示。
//    因此，0.1的指数偏移值 = 1023 - 4 = 1019 = 01111111011
// 3. 尾数：双精度浮点数的尾数占52位，多出来的采用四舍五入制（即：0舍，1入）
//    0.1的小数：10011001 10011001 10011001 10011001 10011001 10011001 10011001 ...
//    四舍五入后：10011001 10011001 10011001 10011001 10011001 10011001 1010
//    因此，0.1的尾数 = 1001100110011001100110011001100110011001100110011010
//    请注意最后四位，是 1010 而不是 1001，因为四舍五入有进位，这个进位就是造成 0.1 + 0.2 不等于 0.3 的原因
// 4. 0.1的IEEE754标准表示为：
//    0011111110111001100110011001100110011001100110011001100110011010

// 第四步：将 0011111110111001100110011001100110011001100110011001100110011010 再转换为十进制
//     0011111110111001100110011001100110011001100110011001100110011010
// S = 0
// E =  01111111011
// M =             1001100110011001100110011001100110011001100110011010
// x = (-1)^S * (1.M) * 2^(E-1023)
//   = (-1)^0 * (1.1001100110011001100110011001100110011001100110011010) * 2^(01111111011 - 1023)
//   = (-1)**0 * (1*2**0 + 1*2**(-1) + 1*2**(-4) + 1*2**(-5) + 1*2**(-8) + 1*2**(-9) + 1*2**(-12) + 1*2**(-13) + 1*2**(-16) + 1*2**(-17) + 1*2**(-20) + 1*2**(-21) + 1*2**(-24) + 1*2**(-25) + 1*2**(-28) + 1*2**(-29) + 1*2**(-32) + 1*2**(-33) + 1*2**(-36) + 1*2**(-37) + 1*2**(-40) + 1*2**(-41) + 1*2**(-44) + 1*2**(-45) + 1*2**(-48) + 1*2**(-49) + 1*2**(-51)) * 2**(1*2**0 + 1*2**1 + 1*2**3 + 1*2**4 + 1*2**5 + 1*2**6 + 1*2**7 + 1*2**8 + 1*2**9 - 1023)
//   = 0.1
console.log((-1)**0 * (1*2**0 + 1*2**(-1) + 1*2**(-4) + 1*2**(-5) + 1*2**(-8) + 1*2**(-9) + 1*2**(-12) + 1*2**(-13) + 1*2**(-16) + 1*2**(-17) + 1*2**(-20) + 1*2**(-21) + 1*2**(-24) + 1*2**(-25) + 1*2**(-28) + 1*2**(-29) + 1*2**(-32) + 1*2**(-33) + 1*2**(-36) + 1*2**(-37) + 1*2**(-40) + 1*2**(-41) + 1*2**(-44) + 1*2**(-45) + 1*2**(-48) + 1*2**(-49) + 1*2**(-51)) * 2**(1*2**0 + 1*2**1 + 1*2**3 + 1*2**4 + 1*2**5 + 1*2**6 + 1*2**7 + 1*2**8 + 1*2**9 - 1023))

// 对于0.2重复上面的步骤
// 第一步：十进制0.2转换成二进制
// 0.2 * 2 = 0.4    整数：0    小数：0.4
// 0.4 * 2 = 0.8    整数：0    小数：0.8
// 0.8 * 2 = 1.6    整数：1    小数：0.6
// 0.6 * 2 = 1.2    整数：1    小数：0.2
// 0.2 * 2 = 0.4    整数：0    小数：0.4
// ...
// 所以：0.2 = 0.00110011...(0011)无限循环

// 第二步：将0.2转换过后的二进制通过科学计数法表示
// 0.00110011...(0011)无限循环 = 1.10011001...(1001)无限循环 * 2^-3

// 第三步：将通过科学计数法表示的二进制转换为IEEE745标准表示
// 规格化，简言之就是求符号位、指数偏移值和尾数
// 1. 符号位：0表示正数，1表示负数
//    因此，0.2的符号位 = 0
// 2. 指数偏移值：双精度浮点数固定偏移值（2^(11-1)-1）加上指数实际值（即2^-3中的-3）的11位二进制表示。
//    因此，0.2的指数偏移值 = 1023 - 3 = 1020 = 01111111100
// 3. 尾数：双精度浮点数的尾数占52位，多出来的采用四舍五入制（即：0舍，1入）
//    0.2的小数：10011001 10011001 10011001 10011001 10011001 10011001 10011001 ...
//    四舍五入后：10011001 10011001 10011001 10011001 10011001 10011001 1010
//    因此，0.1的尾数 = 1001100110011001100110011001100110011001100110011010
//    请注意最后四位，是 1010 而不是 1001，因为四舍五入有进位，这个进位就是造成 0.1 + 0.2 不等于 0.3 的原因
// 4. 0.1的IEEE754标准表示为：
//    0011111111001001100110011001100110011001100110011001100110011010

// 第四步：将 0011111111001001100110011001100110011001100110011001100110011010 再转换为十进制
//     0011111111001001100110011001100110011001100110011001100110011010
// S = 0
// E =  01111111100
// M =             1001100110011001100110011001100110011001100110011010
// x = (-1)^S * (1.M) * 2^(E-1023)
//   = (-1)^0 * (1.1001100110011001100110011001100110011001100110011010) * 2^(01111111100 - 1023)
//   = (-1)**0 * (1*2**0 + 1*2**(-1) + 1*2**(-4) + 1*2**(-5) + 1*2**(-8) + 1*2**(-9) + 1*2**(-12) + 1*2**(-13) + 1*2**(-16) + 1*2**(-17) + 1*2**(-20) + 1*2**(-21) + 1*2**(-24) + 1*2**(-25) + 1*2**(-28) + 1*2**(-29) + 1*2**(-32) + 1*2**(-33) + 1*2**(-36) + 1*2**(-37) + 1*2**(-40) + 1*2**(-41) + 1*2**(-44) + 1*2**(-45) + 1*2**(-48) + 1*2**(-49) + 1*2**(-51)) * 2**(1*2**2 + 1*2**3 + 1*2**4 + 1*2**5 + 1*2**6 + 1*2**7 + 1*2**8 + 1*2**9 - 1023)
//   = 0.2
console.log((-1)**0 * (1*2**0 + 1*2**(-1) + 1*2**(-4) + 1*2**(-5) + 1*2**(-8) + 1*2**(-9) + 1*2**(-12) + 1*2**(-13) + 1*2**(-16) + 1*2**(-17) + 1*2**(-20) + 1*2**(-21) + 1*2**(-24) + 1*2**(-25) + 1*2**(-28) + 1*2**(-29) + 1*2**(-32) + 1*2**(-33) + 1*2**(-36) + 1*2**(-37) + 1*2**(-40) + 1*2**(-41) + 1*2**(-44) + 1*2**(-45) + 1*2**(-48) + 1*2**(-49) + 1*2**(-51)) * 2**(1*2**2 + 1*2**3 + 1*2**4 + 1*2**5 + 1*2**6 + 1*2**7 + 1*2**8 + 1*2**9 - 1023))

// 第五步：计算0.1 + 0.2
//    0.1: 0011111110111001100110011001100110011001100110011001100110011010
// +  0.2: 0011111111001001100110011001100110011001100110011001100110011010

/**
 * 二进制浮点数加减法运算
 * 1. 对阶
 *    对阶的目的是让两个浮点数阶码一致，使尾数可以进行运算
 *    浮点数的尾数实际小数位与阶码有关，若阶码不整齐浮点数的尾数是无法进行运算的
 *    对阶操作是按小阶向大阶看齐
 *
 * 2. 尾数运算
 *
 * 3. 规格化
 *
 * 4. 舍入
 *
 * 5. 溢出判断
 */

// 1. 对阶
// 举例：
//   3.5 * 10^3 + 4.5 * 10^2
// = 3.5 * 10^3 + 0.45 * 10^3
// = (3.5 + 0.45) * 10^3
//
// 再回到0.1 + 0.2的问题当中
// 0.1: 1.1001100110011001100110011001100110011001100110011010 * 2^-4
// 0.2: 1.1001100110011001100110011001100110011001100110011010 * 2^-3
// 对阶：小阶往大阶看齐，即0.1的-4像0.2的-3看齐，阶码(-4) + 1 = -3，尾数向右移1位，右移的1位遵守0舍1入的原则，下面括号中的0将被舍去
// 0.1: 0.1100110011001100110011001100110011001100110011001101(0) * 2^-3

// 2. 尾数运算，此时，0.1 +  0.2 =
//    0.1100110011001100110011001100110011001100110011001101 * 2^-3
// +  1.1001100110011001100110011001100110011001100110011010 * 2^-3
// =
//   10.0110011001100110011001100110011001100110011001100111 * 2^-3

// 3. 规格化
//   10.0110011001100110011001100110011001100110011001100111 * 2^-3
// =  1.0011001100110011001100110011001100110011001100110011(1) * 2^-2

// 4. 舍入，下面括号中的1将进1
//    1.0011001100110011001100110011001100110011001100110011(1) * 2^-2
// =  1.0011001100110011001100110011001100110011001100110100 * 2^-2
// = (1*2**0 + 1*2**-3 + 1*2**-4 + 1*2**-7 + 1*2**-8 + 1*2**-11 + 1*2**-12 + 1*2**-15 + 1*2**-16 + 1*2**-19 + 1*2**-20 + 1*2**-23 + 1*2**-24 + 1*2**-27 + 1*2**-28 + 1*2**-31 + 1*2**-32 + 1*2**-35 + 1*2**-36 + 1*2**-39 + 1*2**-40 + 1*2**-43 + 1*2**-44 + 1*2**-47 + 1*2**-48 + 1*2**-50) * 2**-2
// = 0.30000000000000004
console.log((1*2**0 + 1*2**-3 + 1*2**-4 + 1*2**-7 + 1*2**-8 + 1*2**-11 + 1*2**-12 + 1*2**-15 + 1*2**-16 + 1*2**-19 + 1*2**-20 + 1*2**-23 + 1*2**-24 + 1*2**-27 + 1*2**-28 + 1*2**-31 + 1*2**-32 + 1*2**-35 + 1*2**-36 + 1*2**-39 + 1*2**-40 + 1*2**-43 + 1*2**-44 + 1*2**-47 + 1*2**-48 + 1*2**-50) * 2**-2)

// 5. 判断溢出

// 问：怎么办？
// 答：...

