import { Buffer } from 'buffer';

/**
 * 端序（Endianness），又称字节序、尾序、位序。在计算机领域是指机器存放多字节数据的字节顺序。单字节数据无需考虑
 * 大端序（Big-Endian，大尾序），高位字节放在内存的低地址，低位字节放在内存的高地址。
 * 小端序（Little-Endian，小尾序），低位字节放在内存的低地址，高位字节放在内存的高地址。
 * 端序是与硬件的体系结构相关而与所使用的操作系统无关的概念，目前基本上所有x86系列的PC机都是小端序。
 *
 * 在32位机器上，对于数0x12345678来说，低层表示的方法因端序而排列不同
 * 大端序：
 *         0x12     0x34       0x56       0x78
 * 低地址 0------7 8------15 16------23 24------31 高地址
 *
 * 小端序：
 *         0x78     0x56       0x34       0x12
 * 低地址 0------7 8------15 16------23 24------31 高地址
 */

/**
 * 无符号数，有符号数
 *
 * 无符号数: 所有的位都用于直接表示该值的大小
 * 有符号数: 最高位表示符号位，0表示正数，1表示负数
 *
 * 无符号数，一个字节能表示的值的范围为：0 ~ 255
 * 有符号数，一个字节能表示的值的范围为：-128 ~ +127
 */

/**
 * 原码，反码，补码
 *
 * 无符号数: 原码 = 反码 = 补码
 *
 * 有符号数:
 *  正数: 原码 = 反码 = 补码
 *  负数: 反码 = 原码符号位不变，其余位按位取反
 *       补码 = 反码 + 1
 *
 * 已知补码，怎么求原码？
 * 1. 补码符号位为0，表示正数，原码 = 反码 = 补码
 * 2. 补码符号位为1，表示负数，那么该补码的补码即为原码
 */

/**
 * buf.readBigInt64BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足：0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <bigint> 注意：BigInt 类型的数据必须添加后缀n
 * 从指定的 offset 处的 buf 读取有符号的大端序 64 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
let buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
// <Buffer 00 00 00 00 ff ff ff ff>
// 有符号 64位 大端序：
// 0x  00       00       00       00       ff       ff       ff       ff
// 0b  00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111  // 有符号(正数) 补码
// 0b  00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111  // 有符号(正数) 反码
// 0b  00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111  // 有符号(正数) 原码
// S = 0
// M =  0000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111
// x = (-1)^S * M
// x = (-1)^0 * (0000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111)
// x = 1 * (0000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111)
// x = 0000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111
// x = 4294967295
// console.log(0b000000000000000000000000000000011111111111111111111111111111111); // 4294967295
console.log('buf.readBigInt64BE() = ', buf.readBigInt64BE()); // 4294967295n

/**
 * buf.readBigInt64LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足：0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <bigint> 注意：BigInt 类型的数据必须添加后缀n
 * 从指定的 offset 处的 buf 读取有符号的小端序 64 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
// <Buffer 00 00 00 00 ff ff ff ff>
// 有符号 64位 小端序：
// 0x  ff       ff       ff       ff       00       00       00       00
// 0b  11111111 11111111 11111111 11111111 00000000 00000000 00000000 00000000  // 有符号(负数) 补码
// 0b  10000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111  // 有符号(负数) 该补码的反码
// 0b  10000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000  // 有符号(负数) 该补码的补码，即原码
// S = 1
// M =  0000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000
// x = (-1)^S * M
// x = (-1)^1 * (0000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000)
// x = -1 * (0000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000)
// x = -(0000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000)
// x = -4294967296
// console.log(-0b000000000000000000000000000000100000000000000000000000000000000); // -4294967296
console.log('buf.readBigInt64LE() = ', buf.readBigInt64LE()); // -4294967296n

/**
 * buf.readBigUInt64BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足：0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <bigint> 注意：BigInt 类型的数据必须添加后缀n
 * 从指定的 offset 处的 buf 读取无符号的大端序 64 位整数。
 * 此函数也可在 readBigUint64BE 别名下使用。
 */
buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
// <Buffer 00 00 00 00 ff ff ff ff>
// 无符号 64位 大端序：
// 0x  00       00       00       00       ff       ff       ff       ff
// 0b  00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111  // 无符号
// console.log(0x00000000ffffffff); // 4294967295
// console.log(0b0000000000000000000000000000000011111111111111111111111111111111); // 4294967295
console.log('buf.readBigUInt64BE() = ', buf.readBigUInt64BE()); // 4294967295n

/**
 * buf.readBigUInt64LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足：0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <bigint> 注意：BigInt 类型的数据必须添加后缀n
 * 从指定的 offset 处的 buf 读取无符号的小端序 64 位整数。
 * 此函数也可在 readBigUint64LE 别名下使用。
 */
buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
// <Buffer 00 00 00 00 ff ff ff ff>
// 无符号 64位 小端序：
// 0x  ff       ff       ff       ff       00       00       00       00
// 0b  11111111 11111111 11111111 11111111 00000000 00000000 00000000 00000000  // 无符号
// console.log(0xffffffff00000000); // 18446744069414584000
// console.log(0b1111111111111111111111111111111100000000000000000000000000000000); // 18446744069414584000
console.log('buf.readBigUInt64LE() = ', buf.readBigUInt64LE()); // 18446744069414584000n

/**
 * buf.readInt32BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取有符号的大端序 32 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([0, 0, 0, 5]);
// <Buffer 00 00 00 05>
// 有符号 32位 大端序：
// 0x  00       00       00       05
// 0b  00000000 00000000 00000000 00000101  // 有符号(正数) 补码
// 0b  00000000 00000000 00000000 00000101  // 有符号(正数) 反码
// 0b  00000000 00000000 00000000 00000101  // 有符号(正数) 原码
// S = 0
// M =  0000000 00000000 00000000 00000101
// x = (-1)^S * M
// x = (-1)^0 * (0000000 00000000 00000000 00000101)
// x = 1 * (0000000 00000000 00000000 00000101)
// x = 0000000 00000000 00000000 00000101
// x = 5
// console.log(0b0000000000000000000000000000101); // 5
console.log('buf.readInt32BE() = ', buf.readInt32BE()); // 5

/**
 * buf.readInt32LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取有符号的小端序 32 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([0, 0, 0, 5]);
// <Buffer 00 00 00 05>
// 有符号 32位 小端序：
// 0x  05       00       00       00
// 0b  00000101 00000000 00000000 00000000  // 有符号(正数) 补码
// 0b  00000101 00000000 00000000 00000000  // 有符号(正数) 反码
// 0b  00000101 00000000 00000000 00000000  // 有符号(正数) 原码
// S = 0
// M =  0000101 00000000 00000000 00000000
// x = (-1)^S * M
// x = (-1)^0 * (0000101 00000000 00000000 00000000)
// x = 1 * (0000101 00000000 00000000 00000000)
// x = 0000101 00000000 00000000 00000000
// X = 83886080
// console.log(0b0000101000000000000000000000000); // 83886080
console.log('buf.readInt32LE() = ', buf.readInt32LE()); // 83886080

/**
 * buf.readUInt32BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取无符号的大端序 32 位整数。
 * 此函数也可在 readUint32BE 别名下使用。
 */
buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
// <Buffer 12 34 56 78>
// 无符号 32位 大端序：
// 0x  12       34       56       78
// 0b  00010010 00110100 01010110 01111000  // 无符号
// console.log(0x12345678); // 305419896
// console.log(0b00010010001101000101011001111000); // 305419896
console.log('buf.readUInt32BE() = ', buf.readUInt32BE()); // 305419896

/**
 * buf.readUInt32LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取无符号的小端序 32 位整数。
 * 此函数也可在 readUint32LE 别名下使用。
 */
buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
// <Buffer 12 34 56 78>
// 无符号 32位 小端序：
// 0x  78       56       34       12
// 0b  01111000 01010110 00110100 00010010 // 无符号
// console.log(0x78563412); // 2018915346
// console.log(0b01111000010101100011010000010010); // 2018915346
console.log('buf.readUInt32LE() = ', buf.readUInt32LE()); // 2018915346

/**
 * buf.readInt16BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 2。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取有符号的大端序 16 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([0, 5]);
// <Buffer 00 05>
// 有符号 16位 大端序：
// 0x  00       05
// 0b  00000000 00000101    // 有符号(正数) 补码
// 0b  00000000 00000101    // 有符号(正数) 反码
// 0b  00000000 00000101    // 有符号(正数) 原码
// S = 0
// M =  0000000 00000101
// x = (-1)^S * M
// x = (-1)^0 * (00000000 00000101)
// x = 1 * (00000000 00000101)
// x = 00000000 00000101
// x = 5
// console.log(0b0000000000000101); // 5
console.log('buf.readInt16BE() = ', buf.readInt16BE()); // 5

/**
 * buf.readInt16LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 2。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取有符号的小端序 16 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([0, 5]);
// <Buffer 00 05>
// 有符号 16位 小端序：
// 0x  05       00
// 0b  00000101 00000000    // 有符号(正数) 补码
// 0b  00000101 00000000    // 有符号(正数) 反码
// 0b  00000101 00000000    // 有符号(正数) 原码
// S = 0
// M =  0000101 00000000
// x = (-1)^S * M
// x = (-1)^0 * (0000101 00000000)
// x = 1 * (0000101 00000000)
// x = 0000101 00000000
// x = 1280
// console.log(0b000010100000000); // 1280
console.log('buf.readInt16LE() = ', buf.readInt16LE()); // 1280

/**
 * buf.readUInt16BE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 2。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取无符号的大端序 16 位整数。
 * 此函数也可在 readUint16BE 别名下使用。
 */
buf = Buffer.from([0x12, 0x34, 0x56])
// <Buffer 12 34 56>
// 无符号 16位 大端序：
// 0x  12       34
// 0b  00010010 00110100    // 无符号
// console.log(0x1234); // 4660
// console.log(0b0001001000110100); // 4660
console.log('buf.readUInt16BE() = ', buf.readUInt16BE()); // 4660

/**
 * buf.readUInt16LE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 2。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取无符号的小端序 16 位整数。
 * 此函数也可在 readUint16LE 别名下使用。
 */
buf = Buffer.from([0x12, 0x34, 0x56])
// <Buffer 12 34 56>
// 无符号 16位 小端序：
// 0x  34       12
// 0b  00110100 00010010    // 无符号
// console.log(0x3412); // 13330
// console.log(0b0011010000010010); // 13330
console.log('buf.readUInt16LE() = ', buf.readUInt16LE()); // 13330

/**
 * buf.readInt8([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 1。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定的 offset 处的 buf 读取有符号的 8 位整数。
 * 从 Buffer 读取的整数被解释为二进制补码有符号值。
 */
buf = Buffer.from([-1, 5]);
// <Buffer ff 05>
// 有符号 8位：
// 0x  ff
// 0b  11111111 // 有符号(负数) 补码
// 0b  10000000 // 有符号(负数) 该补码的反码
// 0b  10000001 // 有符号(负数) 该补码的补码，即原码
// S = 1
// M =  0000001
// x = (-1)^S * M
// x = (-1)^1 * (0000001)
// x = -1 * (0000001)
// x = -(0000001)
// x = -1
// console.log(-0b0000001); // -1
console.log('buf.readInt8() = ', buf.readInt8()); // -1

/**
 * buf.readUInt8([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 1。 默认值: 0。
 * 2. 返回: <integer>
 * 从指定 offset 处的 buf 读取无符号 8 位整数。
 * 此函数也可在 readUint8 别名下使用。
 */
buf = Buffer.from([-1, 5]);
// <Buffer ff 05>
// 无符号 8位：
// 0x ff
// 0b 11111111 // 无符号
// console.log(0xff); // 255
// console.log(0b11111111); // 255
console.log('buf.readUInt8() = ', buf.readUInt8()); // 255

/**
 * buf.readIntBE(offset, byteLength)
 */

/**
 * buf.readIntLE(offset, byteLength)
 */

/**
 * buf.readUIntBE(offset, byteLength)
 */

/**
 * buf.readUIntLE(offset, byteLength)
 */

/**
 * IEEE754标准（二进制浮点数表示法）
 * 双精度浮点数，共64位（8字节）：
 * 符号S：1位，0表示正数，1表示负数
 * 指数E：11位，无符号数，0~1023表示负数，1024~2047表示正数
 * 尾数M：52位
 * x = (-1)^S * (1.M) * 2**(E-(2**10-1))
 *   = (-1)^S * (1.M) * 2**(E-1023)
 *
 * 单精度浮点数，共32位（4字节）：
 * 符号S：1位，0表示正数，1表示负数
 * 指数E：8位，无符号数，0~127表示负数，127~255表示正数
 * 尾数M：23位
 * x = (-1)^S * (1.M) * 2**(E-(2**7-1))
 *   = (-1)^S * (1.M) * 2**(E-127)
 */

/**
 * buf.readDoubleBE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <number>
 * 从指定 offset 处的 buf 读取 64 位大端序双精度值。
 */
buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
// <Buffer 01 02 03 04 05 06 07 08>
// 64位大端序：
// 0x  01       02       03       04       05       06       07       08
// 0b  00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000
// S = 0
// E =  0000001 0000
// M =              0010 00000011 00000100 00000101 00000110 00000111 00001000
// x = (-1)^S * (1.M) * 2^(E-1023)
// x = (-1)^0 * (1.0010 00000011 00000100 00000101 00000110 00000111 00001000) * 2^(0000001 0000 - 1023)
// x = (-1)**0 * (1*2**0 + 1*2**(-3) + 1*2**(-11) + 1*2**(-12) + 1*2**(-18) + 1*2**(-26) + 1*2**(-28) + 1*2**(-34) + 1*2**(-35) + 1*2**(-42) + 1*2**(-43) + 1*2**(-44) + 1*2**(-49)) * 2**(1*2**4 - 1023)
// x = 8.20788039913184e-304
console.log('x = ', (-1)**0 * (1*2**0 + 1*2**(-3) + 1*2**(-11) + 1*2**(-12) + 1*2**(-18) + 1*2**(-26) + 1*2**(-28) + 1*2**(-34) + 1*2**(-35) + 1*2**(-42) + 1*2**(-43) + 1*2**(-44) + 1*2**(-49)) * 2**(1*2**4 - 1023));
console.log('buf.readDoubleBE() = ', buf.readDoubleBE()); // 8.20788039913184e-304

/**
 * buf.readDoubleLE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 8。 默认值: 0。
 * 2. 返回: <number>
 * 从指定 offset 处的 buf 读取 64 位小端序双精度值。
 */
buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
// <Buffer 01 02 03 04 05 06 07 08>
// 64位小端序：
// 0x  08       07       06       05       04       03       02       01
// 0b  00001000 00000111 00000110 00000101 00000100 00000011 00000010 00000001
// S = 0
// E =  0001000 0000
// M =              0111 00000110 00000101 00000100 00000011 00000010 00000001
// x = (-1)^S * (1.M) * 2^(E-1023)
// x = (-1)^0 * (1.0111 00000110 00000101 00000100 00000011 00000010 00000001) * 2^(0001000 0000 - 1023)
// x = (-1)**0 * (1*2**0 + 1*2**(-2) + 1*2**(-3) + 1*2**(-4) + 1*2**(-10) + 1*2**(-11) + 1*2**(-18) + 1*2**(-20) + 1*2**(-26) + 1*2**(-35) + 1*2**(-36) + 1*2**(-43) + 1*2**(-52)) * 2**(1*2**7 - 1023)
// x = 5.447603722011605e-270
console.log('x = ', (-1)**0 * (1*2**0 + 1*2**(-2) + 1*2**(-3) + 1*2**(-4) + 1*2**(-10) + 1*2**(-11) + 1*2**(-18) + 1*2**(-20) + 1*2**(-26) + 1*2**(-35) + 1*2**(-36) + 1*2**(-43) + 1*2**(-52)) * 2**(1*2**7 - 1023));
console.log('buf.readDoubleLE() = ', buf.readDoubleLE()); // 5.447603722011605e-270

/**
 * buf.readFloatBE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <number>
 * 从指定 offset 处的 buf 读取 32 位大端序浮点数。
 */
buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
// <Buffer 01 02 03 04 05 06 07 08>
// 32位大端序：
// 0x  01       02       03       04
// 0b  00000001 00000010 00000011 00000100
// S = 0
// E =  0000001 0
// M =           0000010 00000011 00000100
// x = (-1)^S * (1.M) * 2^(E-127)
// x = (-1)^0 * (1.0000010 00000011 00000100) * 2^(0000001 0 - 127)
// x = (-1)**0 * (1*2**0 + 1*2**(-6) + 1*2**(-14) + 1*2**(-15) + 1*2**(-21)) * 2**(1*2**1 - 127)
// x = 2.387939260590663e-38
console.log('x = ', (-1)**0 * (1*2**0 + 1*2**(-6) + 1*2**(-14) + 1*2**(-15) + 1*2**(-21)) * 2**(1*2**1 - 127));
console.log('buf.readFloatBE() = ', buf.readFloatBE()); // 2.387939260590663e-38

/**
 * buf.readFloatLE([offset])
 * 1. offset <integer> 开始读取之前要跳过的字节数。 必须满足 0 <= offset <= buf.length - 4。 默认值: 0。
 * 2. 返回: <number>
 * 从指定 offset 处的 buf 读取 32 位小端序浮点数。
 */
buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
// <Buffer 01 02 03 04 05 06 07 08>
// 32位小端序：
// 0x  04 03 02 01
// 0b  00000100 00000011 00000010 00000001
// S = 0
// E =  0000100 0
// M =           0000011 00000010 00000001
// x = (-1)^S * (1.M) * 2^(E-127)
// x = (-1)^0 * (1.0000011 00000010 00000001) * 2^(0000100 0 - 127)
// x = (-1)**0 * (1*2**0 + 1*2**(-6) + 1*2**(-7) + 1*2**(-14) + 1*2**(-23)) * 2**(1*2**3 - 127)
// x = 1.539989614439558e-36
console.log('x = ', (-1)**0 * (1*2**0 + 1*2**(-6) + 1*2**(-7) + 1*2**(-14) + 1*2**(-23)) * 2**(1*2**3 - 127));
console.log('buf.readFloatLE() = ', buf.readFloatLE()); // 1.539989614439558e-36
